{"version":3,"sources":["injector.js"],"names":[],"mappings":"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","file":"src/di/injector.js","sourceRoot":"/Users/yamaguchi/Desktop/mean-edge/node_modules/angular2/es6/dev/","sourcesContent":["/// <reference path=\"../../typings/es6-promise/es6-promise.d.ts\" />\r\nimport { List, MapWrapper, ListWrapper } from 'angular2/src/facade/collection';\r\nimport { ResolvedBinding, Binding, BindingBuilder, bind } from './binding';\r\nimport { AbstractBindingError, NoBindingError, AsyncBindingError, CyclicDependencyError, InstantiationError, InvalidBindingError } from './exceptions';\r\nimport { FunctionWrapper, Type, isPresent, isBlank } from 'angular2/src/facade/lang';\r\nimport { PromiseWrapper } from 'angular2/src/facade/async';\r\nimport { Key } from './key';\r\nvar _constructing = new Object();\r\nvar _notFound = new Object();\r\nclass _Waiting {\r\n    constructor(promise) {\r\n        this.promise = promise;\r\n    }\r\n}\r\nfunction _isWaiting(obj) {\r\n    return obj instanceof _Waiting;\r\n}\r\n/**\r\n * A dependency injection container used for resolving dependencies.\r\n *\r\n * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\r\n * constructor dependencies.\r\n * In typical use, application code asks for the dependencies in the constructor and they are\r\n * resolved by the `Injector`.\r\n *\r\n * ## Example:\r\n *\r\n * Suppose that we want to inject an `Engine` into class `Car`, we would define it like this:\r\n *\r\n * ```javascript\r\n * class Engine {\r\n * }\r\n *\r\n * class Car {\r\n * \tconstructor(@Inject(Engine) engine) {\r\n * \t}\r\n * }\r\n *\r\n * ```\r\n *\r\n * Next we need to write the code that creates and instantiates the `Injector`. We then ask for the\r\n * `root` object, `Car`, so that the `Injector` can recursively build all of that object's\r\n *dependencies.\r\n *\r\n * ```javascript\r\n * main() {\r\n *   var injector = Injector.resolveAndCreate([Car, Engine]);\r\n *\r\n *   // Get a reference to the `root` object, which will recursively instantiate the tree.\r\n *   var car = injector.get(Car);\r\n * }\r\n * ```\r\n * Notice that we don't use the `new` operator because we explicitly want to have the `Injector`\r\n * resolve all of the object's dependencies automatically.\r\n *\r\n * @exportedAs angular2/di\r\n */\r\nexport class Injector {\r\n    /**\r\n     * @param `bindings` A sparse list of {@link ResolvedBinding}s. See `resolve` for the {@link\r\n     * Injector}.\r\n     * @param `parent` Parent Injector or `null` if root Injector.\r\n     * @param `defaultBindings` Setting to true will auto-create bindings. (Only use with root\r\n     * injector.)\r\n     */\r\n    constructor(bindings, parent, defaultBindings) {\r\n        this._bindings = bindings;\r\n        this._instances = this._createInstances();\r\n        this._parent = parent;\r\n        this._defaultBindings = defaultBindings;\r\n        this._asyncStrategy = new _AsyncInjectorStrategy(this);\r\n        this._syncStrategy = new _SyncInjectorStrategy(this);\r\n    }\r\n    /**\r\n     * Turns a list of binding definitions into an internal resolved list of resolved bindings.\r\n     *\r\n     * A resolution is a process of flattening multiple nested lists and converting individual\r\n     * bindings into a list of {@link ResolvedBinding}s. The resolution can be cached by `resolve`\r\n     * for the {@link Injector} for performance-sensitive code.\r\n     *\r\n     * @param `bindings` can be a list of `Type`, {@link Binding}, {@link ResolvedBinding}, or a\r\n     * recursive list of more bindings.\r\n     *\r\n     * The returned list is sparse, indexed by `id` for the {@link Key}. It is generally not useful to\r\n     *application code\r\n     * other than for passing it to {@link Injector} functions that require resolved binding lists,\r\n     *such as\r\n     * `fromResolvedBindings` and `createChildFromResolved`.\r\n     */\r\n    static resolve(bindings) {\r\n        var resolvedBindings = _resolveBindings(bindings);\r\n        var flatten = _flattenBindings(resolvedBindings, MapWrapper.create());\r\n        return _createListOfBindings(flatten);\r\n    }\r\n    /**\r\n     * Resolves bindings and creates an injector based on those bindings. This function is slower than\r\n     * the corresponding `fromResolvedBindings` because it needs to resolve bindings first. See\r\n     *`resolve`\r\n     * for the {@link Injector}.\r\n     *\r\n     * Prefer `fromResolvedBindings` in performance-critical code that creates lots of injectors.\r\n     *\r\n     * @param `bindings` can be a list of `Type`, {@link Binding}, {@link ResolvedBinding}, or a\r\n     *recursive list of more\r\n     * bindings.\r\n     * @param `defaultBindings` Setting to true will auto-create bindings.\r\n     */\r\n    static resolveAndCreate(bindings, { defaultBindings = false } = {}) {\r\n        return new Injector(Injector.resolve(bindings), null, defaultBindings);\r\n    }\r\n    /**\r\n     * Creates an injector from previously resolved bindings. This bypasses resolution and flattening.\r\n     * This API is the recommended way to construct injectors in performance-sensitive parts.\r\n     *\r\n     * @param `bindings` A sparse list of {@link ResolvedBinding}s. See `resolve` for the {@link\r\n     *Injector}.\r\n     * @param `defaultBindings` Setting to true will auto-create bindings.\r\n     */\r\n    static fromResolvedBindings(bindings, { defaultBindings = false } = {}) {\r\n        return new Injector(bindings, null, defaultBindings);\r\n    }\r\n    /**\r\n     * Direct parent of this injector.\r\n     */\r\n    get parent() { return this._parent; }\r\n    /**\r\n     * Retrieves an instance from the injector.\r\n     *\r\n     * @param `token`: usually the `Type` of an object. (Same as the token used while setting up a\r\n     *binding).\r\n     * @returns an instance represented by the token. Throws if not found.\r\n     */\r\n    get(token) { return this._getByKey(Key.get(token), false, false, false); }\r\n    /**\r\n     * Retrieves an instance from the injector.\r\n     *\r\n     * @param `token`: usually a `Type`. (Same as the token used while setting up a binding).\r\n     * @returns an instance represented by the token. Returns `null` if not found.\r\n     */\r\n    getOptional(token) { return this._getByKey(Key.get(token), false, false, true); }\r\n    /**\r\n     * Retrieves an instance from the injector asynchronously. Used with asynchronous bindings.\r\n     *\r\n     * @param `token`: usually a `Type`. (Same as token used while setting up a binding).\r\n     * @returns a `Promise` which resolves to the instance represented by the token.\r\n     */\r\n    asyncGet(token) { return this._getByKey(Key.get(token), true, false, false); }\r\n    /**\r\n     * Creates a child injector and loads a new set of bindings into it.\r\n     *\r\n     * A resolution is a process of flattening multiple nested lists and converting individual\r\n     * bindings into a list of {@link ResolvedBinding}s. The resolution can be cached by `resolve`\r\n     * for the {@link Injector} for performance-sensitive code.\r\n     *\r\n     * @param `bindings` can be a list of `Type`, {@link Binding}, {@link ResolvedBinding}, or a\r\n     * recursive list of more bindings.\r\n     *\r\n     */\r\n    resolveAndCreateChild(bindings) {\r\n        return new Injector(Injector.resolve(bindings), this, false);\r\n    }\r\n    /**\r\n     * Creates a child injector and loads a new set of {@link ResolvedBinding}s into it.\r\n     *\r\n     * @param `bindings`: A sparse list of {@link ResolvedBinding}s.\r\n     * See `resolve` for the {@link Injector}.\r\n     * @returns a new child {@link Injector}.\r\n     */\r\n    createChildFromResolved(bindings) {\r\n        return new Injector(bindings, this, false);\r\n    }\r\n    _createInstances() { return ListWrapper.createFixedSize(Key.numberOfKeys + 1); }\r\n    _getByKey(key, returnPromise, returnLazy, optional) {\r\n        if (returnLazy) {\r\n            return () => this._getByKey(key, returnPromise, false, optional);\r\n        }\r\n        var strategy = returnPromise ? this._asyncStrategy : this._syncStrategy;\r\n        var instance = strategy.readFromCache(key);\r\n        if (instance !== _notFound)\r\n            return instance;\r\n        instance = strategy.instantiate(key);\r\n        if (instance !== _notFound)\r\n            return instance;\r\n        if (isPresent(this._parent)) {\r\n            return this._parent._getByKey(key, returnPromise, returnLazy, optional);\r\n        }\r\n        if (optional) {\r\n            return null;\r\n        }\r\n        else {\r\n            throw new NoBindingError(key);\r\n        }\r\n    }\r\n    _resolveDependencies(key, binding, forceAsync) {\r\n        try {\r\n            var getDependency = d => this._getByKey(d.key, forceAsync || d.asPromise, d.lazy, d.optional);\r\n            return ListWrapper.map(binding.dependencies, getDependency);\r\n        }\r\n        catch (e) {\r\n            this._clear(key);\r\n            if (e instanceof AbstractBindingError)\r\n                e.addKey(key);\r\n            throw e;\r\n        }\r\n    }\r\n    _getInstance(key) {\r\n        if (this._instances.length <= key.id)\r\n            return null;\r\n        return ListWrapper.get(this._instances, key.id);\r\n    }\r\n    _setInstance(key, obj) { ListWrapper.set(this._instances, key.id, obj); }\r\n    _getBinding(key) {\r\n        var binding = this._bindings.length <= key.id ? null : ListWrapper.get(this._bindings, key.id);\r\n        if (isBlank(binding) && this._defaultBindings) {\r\n            var token = key.token;\r\n            return bind(key.token).toClass(token).resolve();\r\n        }\r\n        else {\r\n            return binding;\r\n        }\r\n    }\r\n    _markAsConstructing(key) { this._setInstance(key, _constructing); }\r\n    _clear(key) { this._setInstance(key, null); }\r\n}\r\nclass _SyncInjectorStrategy {\r\n    constructor(injector) {\r\n        this.injector = injector;\r\n    }\r\n    readFromCache(key) {\r\n        if (key.token === Injector) {\r\n            return this.injector;\r\n        }\r\n        var instance = this.injector._getInstance(key);\r\n        if (instance === _constructing) {\r\n            throw new CyclicDependencyError(key);\r\n        }\r\n        else if (isPresent(instance) && !_isWaiting(instance)) {\r\n            return instance;\r\n        }\r\n        else {\r\n            return _notFound;\r\n        }\r\n    }\r\n    instantiate(key) {\r\n        var binding = this.injector._getBinding(key);\r\n        if (isBlank(binding))\r\n            return _notFound;\r\n        if (binding.providedAsPromise)\r\n            throw new AsyncBindingError(key);\r\n        // add a marker so we can detect cyclic dependencies\r\n        this.injector._markAsConstructing(key);\r\n        var deps = this.injector._resolveDependencies(key, binding, false);\r\n        return this._createInstance(key, binding, deps);\r\n    }\r\n    _createInstance(key, binding, deps) {\r\n        try {\r\n            var instance = FunctionWrapper.apply(binding.factory, deps);\r\n            this.injector._setInstance(key, instance);\r\n            return instance;\r\n        }\r\n        catch (e) {\r\n            this.injector._clear(key);\r\n            throw new InstantiationError(e, key);\r\n        }\r\n    }\r\n}\r\nclass _AsyncInjectorStrategy {\r\n    constructor(injector) {\r\n        this.injector = injector;\r\n    }\r\n    readFromCache(key) {\r\n        if (key.token === Injector) {\r\n            return PromiseWrapper.resolve(this.injector);\r\n        }\r\n        var instance = this.injector._getInstance(key);\r\n        if (instance === _constructing) {\r\n            throw new CyclicDependencyError(key);\r\n        }\r\n        else if (_isWaiting(instance)) {\r\n            return instance.promise;\r\n        }\r\n        else if (isPresent(instance)) {\r\n            return PromiseWrapper.resolve(instance);\r\n        }\r\n        else {\r\n            return _notFound;\r\n        }\r\n    }\r\n    instantiate(key) {\r\n        var binding = this.injector._getBinding(key);\r\n        if (isBlank(binding))\r\n            return _notFound;\r\n        // add a marker so we can detect cyclic dependencies\r\n        this.injector._markAsConstructing(key);\r\n        var deps = this.injector._resolveDependencies(key, binding, true);\r\n        var depsPromise = PromiseWrapper.all(deps);\r\n        var promise = PromiseWrapper.then(depsPromise, null, (e) => this._errorHandler(key, e))\r\n            .then(deps => this._findOrCreate(key, binding, deps))\r\n            .then(instance => this._cacheInstance(key, instance));\r\n        this.injector._setInstance(key, new _Waiting(promise));\r\n        return promise;\r\n    }\r\n    _errorHandler(key, e) {\r\n        if (e instanceof AbstractBindingError)\r\n            e.addKey(key);\r\n        return PromiseWrapper.reject(e);\r\n    }\r\n    _findOrCreate(key, binding, deps) {\r\n        try {\r\n            var instance = this.injector._getInstance(key);\r\n            if (!_isWaiting(instance))\r\n                return instance;\r\n            return FunctionWrapper.apply(binding.factory, deps);\r\n        }\r\n        catch (e) {\r\n            this.injector._clear(key);\r\n            throw new InstantiationError(e, key);\r\n        }\r\n    }\r\n    _cacheInstance(key, instance) {\r\n        this.injector._setInstance(key, instance);\r\n        return instance;\r\n    }\r\n}\r\nfunction _resolveBindings(bindings) {\r\n    var resolvedList = ListWrapper.createFixedSize(bindings.length);\r\n    for (var i = 0; i < bindings.length; i++) {\r\n        var unresolved = bindings[i];\r\n        var resolved;\r\n        if (unresolved instanceof ResolvedBinding) {\r\n            resolved = unresolved; // ha-ha! I'm easily amused\r\n        }\r\n        else if (unresolved instanceof Type) {\r\n            resolved = bind(unresolved).toClass(unresolved).resolve();\r\n        }\r\n        else if (unresolved instanceof Binding) {\r\n            resolved = unresolved.resolve();\r\n        }\r\n        else if (unresolved instanceof List) {\r\n            resolved = _resolveBindings(unresolved);\r\n        }\r\n        else if (unresolved instanceof BindingBuilder) {\r\n            throw new InvalidBindingError(unresolved.token);\r\n        }\r\n        else {\r\n            throw new InvalidBindingError(unresolved);\r\n        }\r\n        resolvedList[i] = resolved;\r\n    }\r\n    return resolvedList;\r\n}\r\nfunction _createListOfBindings(flattenedBindings) {\r\n    var bindings = ListWrapper.createFixedSize(Key.numberOfKeys + 1);\r\n    MapWrapper.forEach(flattenedBindings, (v, keyId) => bindings[keyId] = v);\r\n    return bindings;\r\n}\r\nfunction _flattenBindings(bindings, res) {\r\n    ListWrapper.forEach(bindings, function (b) {\r\n        if (b instanceof ResolvedBinding) {\r\n            MapWrapper.set(res, b.key.id, b);\r\n        }\r\n        else if (b instanceof List) {\r\n            _flattenBindings(b, res);\r\n        }\r\n    });\r\n    return res;\r\n}\r\n//# sourceMappingURL=injector.js.map"]}