{"version":3,"sources":["interfaces.js"],"names":[],"mappings":"AAAA,KAAK,SAAS,AAAC,iBAAoB,UAAS,SAAQ;;;;;;;;AAApD,OAAO;AACD,UAAM,GADZ,SAAS,IAAG,CAAG;AAAf,cAAoB,KAAG,QAAkB,CAAC;IAElC,CADuB;AACzB,UAAM;iBAEY,KAAG;AAJ3B,cAAQ,AAAC,0BAAqC,CAAA;AAA9C,4BAAA,SAAQ,AAAC;AAKF,eAAM,oBAAkB,KAE/B;AALU,aAAO,CAAA,CAAC,eAAc,YAAY,CAAC,AAAC,uBAI1C,WAAU,CAAV,UAAY,UAAS,CAAG;AAAE,iBAAO,KAAG,CAAC;UAAE,MAHqB,CAAC;MACzD,AAAC,EAAC,CAJ0B,CAAA;AAApC,cAAQ,AAAC,4CAAqC,CAAA;AAA9C,wBAAA,SAAQ,AAAC;AAiCF,eAAM,gBAAc,KAI3B;AAnCU,aAAO,CAAA,CAAC,eAAc,YAAY,CAAC,AAAC,mBAgC1C,yBAAwB,CAAxB,UAA0B,IAAG,CAAG,CAAA,cAAa,CAAG,CAAA,gBAAe,CAAG,CAAA,gBAAe,AAAiC,CAAG;cAAjC,sBAAoB,6CAAI,QAAM;AAC9G,iBAAO,KAAG,CAAC;UACf,MAjC4D,CAAC;MACzD,AAAC,EAAC,CAJ0B,CAAA;AAApC,cAAQ,AAAC,oCAAqC,CAAA;AAA9C,yBAAA,SAAQ,AAAC;AAsCF,eAAM,iBAAe,KAE5B;AAtCU,aAAO,CAAA,CAAC,eAAc,YAAY,CAAC,AAAC,oBAqC1C,eAAc,CAAd,UAAgB,aAAY,CAAG,CAAA,KAAI,CAAG,GAAE,MApCoB,CAAC;MACzD,AAAC,EAAC,CAJ0B,CAAA;AAApC,cAAQ,AAAC,sCAAqC,CAAA;AAA9C,uBAAA,SAAQ,AAAC;AAyCF,eAAM,eAAa,KAW1B;AAlDU,aAAO,CAAA,CAAC,eAAc,YAAY,CAAC,AAAC;AAwC1C,iBAAO,CAAP,UAAS,EAAC,CAAG,GAAE;AACf,0BAAgB,CAAhB,UAAkB,EAAC,CAAG,GAAE;AACxB,oBAAU,CAAV,UAAY,EAAC,CAAG,GAAE;AAClB,6BAAmB,CAAnB,UAAqB,EAAC,CAAG,GAAE;AAC3B,eAAK,CAAL,UAAM,AAAC,CAAE,GAAE;AACX,gBAAM,CAAN,UAAQ,OAAM,CAAG,CAAA,MAAK,CAAG,CAAA,UAAS,CAAG,GAAE;AACvC,kBAAQ,CAAR,UAAS,AAAC,CAAE,GAAE;AACd,kCAAwB,CAAxB,UAAyB,AAAC,CAAE,GAAE;AAC9B,sBAAY,CAAZ,UAAa,AAAC,CAAE,GAAE;AAClB,uBAAa,CAAb,UAAc,AAAC,CAAE,GAAE;AAAA,aAhDyC,CAAC;MACzD,AAAC,EAAC,CAJ0B,CAAA;AAApC,cAAQ,AAAC,kCAAqC,CAAA;IAEf;EAC3B,CAAA;AADI,CAAC,CAAC;AAmD2B","file":"src/change_detection/interfaces.js","sourceRoot":"/Users/yamaguchi/Desktop/mean-edge/node_modules/angular2/es6/dev/","sourcesContent":["import { DEFAULT } from './constants';\r\n// HACK: workaround for Traceur behavior.\r\n// It expects all transpiled modules to contain this marker.\r\n// TODO: remove this when we no longer use traceur\r\nexport var __esModule = true;\r\nexport class ProtoChangeDetector {\r\n    instantiate(dispatcher) { return null; }\r\n}\r\n/**\r\n * Interface used by Angular to control the change detection strategy for an application.\r\n *\r\n * Angular implements the following change detection strategies by default:\r\n *\r\n * - {@link DynamicChangeDetection}: slower, but does not require `eval()`.\r\n * - {@link JitChangeDetection}: faster, but requires `eval()`.\r\n *\r\n * In JavaScript, you should always use `JitChangeDetection`, unless you are in an environment that\r\n *has\r\n * [CSP](https://developer.mozilla.org/en-US/docs/Web/Security/CSP), such as a Chrome Extension.\r\n *\r\n * In Dart, use `DynamicChangeDetection` during development. The Angular transformer generates an\r\n *analog to the\r\n * `JitChangeDetection` strategy at compile time.\r\n *\r\n *\r\n * See: {@link DynamicChangeDetection}, {@link JitChangeDetection}\r\n *\r\n * # Example\r\n * ```javascript\r\n * bootstrap(MyApp, [bind(ChangeDetection).toClass(DynamicChangeDetection)]);\r\n * ```\r\n * @exportedAs angular2/change_detection\r\n */\r\nexport class ChangeDetection {\r\n    createProtoChangeDetector(name, bindingRecords, variableBindings, directiveRecords, changeControlStrategy = DEFAULT) {\r\n        return null;\r\n    }\r\n}\r\nexport class ChangeDispatcher {\r\n    notifyOnBinding(bindingRecord, value) { }\r\n}\r\nexport class ChangeDetector {\r\n    addChild(cd) { }\r\n    addShadowDomChild(cd) { }\r\n    removeChild(cd) { }\r\n    removeShadowDomChild(cd) { }\r\n    remove() { }\r\n    hydrate(context, locals, directives) { }\r\n    dehydrate() { }\r\n    markPathToRootAsCheckOnce() { }\r\n    detectChanges() { }\r\n    checkNoChanges() { }\r\n}\r\n//# sourceMappingURL=interfaces.js.map"]}