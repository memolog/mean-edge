{"version":3,"sources":["annotations.js"],"names":[],"mappings":"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","file":"angular2/src/core/annotations_impl/annotations.js","sourcesContent":["import {CONST, normalizeBlank, isPresent} from 'angular2/src/facade/lang';\nimport {ListWrapper, List} from 'angular2/src/facade/collection';\nimport {Injectable} from 'angular2/src/di/annotations_impl';\nimport {DEFAULT} from 'angular2/change_detection';\n\n// type StringMap = {[idx: string]: string};\n\n/**\n * Directives allow you to attach behavior to elements in the DOM.\n *\n * {@link Directive}s with an embedded view are called {@link Component}s.\n *\n * A directive consists of a single directive annotation and a controller class. When the directive's `selector` matches\n * elements in the DOM, the following steps occur:\n *\n * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor arguments.\n * 2. Angular instantiates directives for each matched element using `ElementInjector` in a depth-first order,\n *    as declared in the HTML.\n *\n * ## Understanding How Injection Works\n *\n * There are three stages of injection resolution.\n * - *Pre-existing Injectors*:\n *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if the dependency was\n *     specified as `@Optional`, returns `null`.\n *   - The platform injector resolves browser singleton resources, such as: cookies, title, location, and others.\n * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow the same parent-child hierarchy\n *     as the component instances in the DOM.\n * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each element has an `ElementInjector`\n *     which follow the same parent-child hierarchy as the DOM elements themselves.\n *\n * When a template is instantiated, it also must instantiate the corresponding directives in a depth-first order. The\n * current `ElementInjector` resolves the constructor dependencies for each directive.\n *\n * Angular then resolves dependencies as follows, according to the order in which they appear in the {@link View}:\n *\n * 1. Dependencies on the current element\n * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary\n * 3. Dependencies on component injectors and their parents until it encounters the root component\n * 4. Dependencies on pre-existing injectors\n *\n *\n * The `ElementInjector` can inject other directives, element-specific special objects, or it can delegate to the parent\n * injector.\n *\n * To inject other directives, declare the constructor parameter as:\n * - `directive:DirectiveType`: a directive on the current element only\n * - `@Ancestor() directive:DirectiveType`: any directive that matches the type between the current element and the\n *    Shadow DOM root. Current element is not included in the resolution, therefore even if it could resolve it, it will\n *    be ignored.\n * - `@Parent() directive:DirectiveType`: any directive that matches the type on a direct parent element only.\n * - `@Children query:Query<DirectiveType>`: A live collection of direct child directives (will be implemented in later release).\n * - `@Descendants query:Query<DirectiveType>`: A live collection of any child directives (will be implemented in later relaese).\n *\n * To inject element-specific special objects, declare the constructor parameter as:\n * - `element: ElementRef` to obtain a reference to logical element in the view.\n * - `viewContainer: ViewContainerRef` to control child template instantiation, for {@link Directive} directives only\n * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.\n *\n * ## Example\n *\n * The following example demonstrates how dependency injection resolves constructor arguments in practice.\n *\n *\n * Assume this HTML template:\n *\n * ```\n * <div dependency=\"1\">\n *   <div dependency=\"2\">\n *     <div dependency=\"3\" my-directive>\n *       <div dependency=\"4\">\n *         <div dependency=\"5\"></div>\n *       </div>\n *       <div dependency=\"6\"></div>\n *     </div>\n *   </div>\n * </div>\n * ```\n *\n * With the following `dependency` decorator and `SomeService` injectable class.\n *\n * ```\n * @Injectable()\n * class SomeService {\n * }\n *\n * @Directive({\n *   selector: '[dependency]',\n *   properties: {\n *     'id':'dependency'\n *   }\n * })\n * class Dependency {\n *   id:string;\n * }\n * ```\n *\n * Let's step through the different ways in which `MyDirective` could be declared...\n *\n *\n * ### No injection\n *\n * Here the constructor is declared with no arguments, therefore nothing is injected into `MyDirective`.\n *\n * ```\n * @Directive({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor() {\n *   }\n * }\n * ```\n *\n * This directive would be instantiated with no dependencies.\n *\n *\n * ### Component-level injection\n *\n * Directives can inject any injectable instance from the closest component injector or any of its parents.\n *\n * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type from the parent\n * component's injector.\n * ```\n * @Directive({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(someService: SomeService) {\n *   }\n * }\n * ```\n *\n * This directive would be instantiated with a dependency on `SomeService`.\n *\n *\n * ### Injecting a directive from the current element\n *\n * Directives can inject other directives declared on the current element.\n *\n * ```\n * @Directive({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(dependency: Dependency) {\n *     expect(dependency.id).toEqual(3);\n *   }\n * }\n * ```\n * This directive would be instantiated with `Dependency` declared at the same element, in this case `dependency=\"3\"`.\n *\n *\n * ### Injecting a directive from a direct parent element\n *\n * Directives can inject other directives declared on a direct parent element. By definition, a directive with a\n * `@Parent` annotation does not attempt to resolve dependencies for the current element, even if this would satisfy\n * the dependency.\n *\n * ```\n * @Directive({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@Parent() dependency: Dependency) {\n *     expect(dependency.id).toEqual(2);\n *   }\n * }\n * ```\n * This directive would be instantiated with `Dependency` declared at the parent element, in this case `dependency=\"2\"`.\n *\n *\n * ### Injecting a directive from any ancestor elements\n *\n * Directives can inject other directives declared on any ancestor element (in the current Shadow DOM), i.e. on the\n * parent element and its parents. By definition, a directive with an `@Ancestor` annotation does not attempt to\n * resolve dependencies for the current element, even if this would satisfy the dependency.\n *\n * ```\n * @Directive({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@Ancestor() dependency: Dependency) {\n *     expect(dependency.id).toEqual(2);\n *   }\n * }\n * ```\n *\n * Unlike the `@Parent` which only checks the parent, `@Ancestor` checks the parent, as well as its\n * parents recursively. If `dependency=\"2\"` didn't exist on the direct parent, this injection would have returned\n * `dependency=\"1\"`.\n *\n *\n * ### Injecting a live collection of direct child directives\n *\n *\n * A directive can also query for other child directives. Since parent directives are instantiated before child\n * directives, a directive can't simply inject the list of child directives. Instead, the directive\n * injects a {@link QueryList}, which updates its contents as children are added, removed, or moved by a directive\n * that uses a {@link ViewContainerRef} such as a `for`, an `if`, or a `switch`.\n *\n * ```\n * @Directive({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@Query(Marker) dependencies:QueryList<Maker>) {\n *   }\n * }\n * ```\n *\n * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and 6. Here, `Dependency`\n * 5 would not be included, because it is not a direct child.\n *\n * ### Injecting a live collection of descendant directives\n *\n * Note: This is will be implemented in later release. ()\n *\n * Similar to `@Children` above, but also includes the children of the child elements.\n *\n * ```\n * @Directive({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@QueryDescendents(Marker) dependencies:QueryList<Maker>) {\n *   }\n * }\n * ```\n *\n * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.\n *\n * ### Optional injection\n *\n * The normal behavior of directives is to return an error when a specified dependency cannot be resolved. If you\n * would like to inject `null` on unresolved dependency instead, you can annotate that dependency with `@Optional()`.\n * This explicitly permits the author of a template to treat some of the surrounding directives as optional.\n *\n * ```\n * @Directive({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@Optional() dependency:Dependency) {\n *   }\n * }\n * ```\n *\n * This directive would be instantiated with a `Dependency` directive found on the current element. If none can be\n * found, the injector supplies `null` instead of throwing an error.\n *\n * ## Example\n *\n * Here we use a decorator directive to simply define basic tool-tip behavior.\n *\n * ```\n * @Directive({\n *   selector: '[tooltip]',\n *   properties: {\n *     'text': 'tooltip'\n *   },\n *   hostListeners: {\n *     'onmouseenter': 'onMouseEnter()',\n *     'onmouseleave': 'onMouseLeave()'\n *   }\n * })\n * class Tooltip{\n *   text:string;\n *   overlay:Overlay; // NOT YET IMPLEMENTED\n *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED\n *\n *   constructor(overlayManager:OverlayManager) {\n *     this.overlay = overlay;\n *   }\n *\n *   onMouseEnter() {\n *     // exact signature to be determined\n *     this.overlay = this.overlayManager.open(text, ...);\n *   }\n *\n *   onMouseLeave() {\n *     this.overlay.close();\n *     this.overlay = null;\n *   }\n * }\n * ```\n * In our HTML template, we can then add this behavior to a `<div>` or any other element with the `tooltip` selector,\n * like so:\n *\n * ```\n * <div tooltip=\"some text here\"></div>\n * ```\n *\n * Directives can also control the instantiation, destruction, and positioning of inline template elements:\n *\n * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at runtime.\n * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a location in the current view\n * where these actions are performed.\n *\n * Views are always created as children of the current {@link View}, and as siblings of the `<template>` element. Thus a\n * directive in a child view cannot inject the directive that created it.\n *\n * Since directives that create views via ViewContainers are common in Angular, and using the full `<template>` element syntax is wordy, Angular\n * also supports a shorthand notation: `<li *foo=\"bar\">` and `<li template=\"foo: bar\">` are equivalent.\n *\n * Thus,\n *\n * ```\n * <ul>\n *   <li *foo=\"bar\" title=\"text\"></li>\n * </ul>\n * ```\n *\n * Expands in use to:\n *\n * ```\n * <ul>\n *   <template [foo]=\"bar\">\n *     <li title=\"text\"></li>\n *   </template>\n * </ul>\n * ```\n *\n * Notice that although the shorthand places `*foo=\"bar\"` within the `<li>` element, the binding for the directive\n * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.\n *\n *\n * ## Example\n *\n * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.\n *\n * Here is a simple directive that triggers on an `unless` selector:\n *\n * ```\n * @Directive({\n *   selector: '[unless]',\n *   properties: {\n *     'unless': 'unless'\n *   }\n * })\n * export class Unless {\n *   viewContainer: ViewContainerRef;\n *   protoViewRef: ProtoViewRef;\n *   prevCondition: boolean;\n *\n *   constructor(viewContainer: ViewContainerRef, protoViewRef: ProtoViewRef) {\n *     this.viewContainer = viewContainer;\n *     this.protoViewRef = protoViewRef;\n *     this.prevCondition = null;\n *   }\n *\n *   set unless(newCondition) {\n *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {\n *       this.prevCondition = true;\n *       this.viewContainer.clear();\n *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {\n *       this.prevCondition = false;\n *       this.viewContainer.create(this.protoViewRef);\n *     }\n *   }\n * }\n * ```\n *\n * We can then use this `unless` selector in a template:\n * ```\n * <ul>\n *   <li *unless=\"expr\"></li>\n * </ul>\n * ```\n *\n * Once the directive instantiates the child view, the shorthand notation for the template expands and the result is:\n *\n * ```\n * <ul>\n *   <template [unless]=\"exp\">\n *     <li></li>\n *   </template>\n *   <li></li>\n * </ul>\n * ```\n *\n * Note also that although the `<li></li>` template still exists inside the `<template></template>`, the instantiated\n * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.\n *\n * @exportedAs angular2/annotations\n */\nexport class Directive extends Injectable {\n  /**\n   * The CSS selector that triggers the instantiation of a directive.\n   *\n   * Angular only allows directives to trigger on CSS selectors that do not cross element boundaries.\n   *\n   * `selector` may be declared as one of the following:\n   *\n   * - `element-name`: select by element name.\n   * - `.class`: select by class name.\n   * - `[attribute]`: select by attribute name.\n   * - `[attribute=value]`: select by attribute name and value.\n   * - `:not(sub_selector)`: select only if the element does not match the `sub_selector`.\n   * - `selector1, selector2`: select if either `selector1` or `selector2` matches.\n   *\n   *\n   * ## Example\n   *\n   * Suppose we have a directive with an `input[type=text]` selector.\n   *\n   * And the following HTML:\n   *\n   * ```html\n   * <form>\n   *   <input type=\"text\">\n   *   <input type=\"radio\">\n   * <form>\n   * ```\n   *\n   * The directive would only be instantiated on the `<input type=\"text\">` element.\n   *\n   */\n  selector:string;\n\n  /**\n   * Enumerates the set of properties that accept data binding for a directive.\n   *\n   * The `properties` property defines a set of `directiveProperty` to `bindingProperty`\n   * key-value pairs:\n   *\n   * - `directiveProperty` specifies the component property where the value is written.\n   * - `bindingProperty` specifies the DOM property where the value is read from.\n   *\n   * You can include a {@link Pipe} when specifying a `bindingProperty` to allow for data transformation and structural\n   * change detection of the value. These pipes will be evaluated in the context of this component.\n   *\n   *\n   * ## Syntax\n   *\n   * ```\n   * @Directive({\n   *   properties: {\n   *     'directiveProperty1': 'bindingProperty1',\n   *     'directiveProperty2': 'bindingProperty2 | pipe1 | ...',\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   *\n   * ## Basic Property Binding\n   *\n   * We can easily build a simple `Tooltip` directive that exposes a `tooltip` property, which can be used in templates\n   * with standard Angular syntax. For example:\n   *\n   * ```\n   * @Directive({\n   *   selector: '[tooltip]',\n   *   properties: {\n   *     'text': 'tooltip'\n   *   }\n   * })\n   * class Tooltip {\n   *   set text(text) {\n   *     // This will get called every time the 'tooltip' binding changes with the new value.\n   *   }\n   * }\n   * ```\n   *\n   * We can then bind to the `tooltip' property as either an expression (`someExpression`) or as a string literal, as\n   * shown in the HTML template below:\n   *\n   * ```html\n   * <div [tooltip]=\"someExpression\">...</div>\n   * <div tooltip=\"Some Text\">...</div>\n   * ```\n   *\n   * Whenever the `someExpression` expression changes, the `properties` declaration instructs\n   * Angular to update the `Tooltip`'s `text` property.\n   *\n   *\n   *\n   * ## Bindings With Pipes\n   *\n   * You can also use pipes when writing binding definitions for a directive.\n   *\n   * For example, we could write a binding that updates the directive on structural changes, rather than on reference\n   * changes, as normally occurs in change detection.\n   *\n   * See {@link Pipe} and {@link keyValDiff} documentation for more details.\n   *\n   * ```\n   * @Directive({\n   *   selector: '[class-set]',\n   *   properties: {\n   *     'classChanges': 'classSet | keyValDiff'\n   *   }\n   * })\n   * class ClassSet {\n   *   set classChanges(changes:KeyValueChanges) {\n   *     // This will get called every time the `class-set` expressions changes its structure.\n   *   }\n   * }\n   * ```\n   *\n   * The template that this directive is used in may also contain its own pipes. For example:\n   *\n   * ```html\n   * <div [class-set]=\"someExpression | somePipe\">\n   * ```\n   *\n   * In this case, the two pipes compose as if they were inlined: `someExpression | somePipe | keyValDiff`.\n   *\n   */\n  properties:any; //  StringMap\n\n  /**\n   * Enumerates the set of emitted events.\n   *\n   * ## Syntax\n   *\n   * ```\n   * @Component({\n   *   events: ['statusChange']\n   * })\n   * class TaskComponent {\n   *   statusChange:EventEmitter;\n   *\n   *   constructor() {\n   *     this.statusChange = new EventEmitter();\n   *   }\n   *\n   *   onComplete() {\n   *     this.statusChange.next('completed');\n   *   }\n   * }\n   * ```\n   */\n  events:List<string>;\n\n  /**\n   * Specifies which DOM hostListeners a directive listens to.\n   *\n   * The `hostListeners` property defines a set of `event` to `method` key-value pairs:\n   *\n   * - `event1`: the DOM event that the directive listens to.\n   * - `statement`: the statement to execute when the event occurs.\n   * If the evalutation of the statement returns `false`, then `preventDefault`is applied on the DOM event.\n   *\n   * To listen to global events, a target must be added to the event name.\n   * The target can be `window`, `document` or `body`.\n   *\n   * When writing a directive event binding, you can also refer to the following local variables:\n   * - `$event`: Current event object which triggered the event.\n   * - `$target`: The source of the event. This will be either a DOM element or an Angular directive.\n   *   (will be implemented in later release)\n   *\n   *\n   * ## Syntax\n   *\n   * ```\n   * @Directive({\n   *   hostListeners: {\n   *     'event1': 'onMethod1(arguments)',\n   *     'target:event2': 'onMethod2(arguments)',\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   * ## Basic Event Binding:\n   *\n   * Suppose you want to write a directive that triggers on `change` events in the DOM and on `resize` events in window.\n   * You would define the event binding as follows:\n   *\n   * ```\n   * @Directive({\n   *   selector: 'input',\n   *   hostListeners: {\n   *     'change': 'onChange($event)',\n   *     'window:resize': 'onResize($event)'\n   *   }\n   * })\n   * class InputDirective {\n   *   onChange(event:Event) {\n   *   }\n   *   onResize(event:Event) {\n   *   }\n   * }\n   * ```\n   *\n   * Here the `onChange` method of `InputDirective` is invoked whenever the DOM element fires the 'change' event.\n   *\n   */\n  hostListeners:any; //  StringMap\n\n\n  /**\n   * Specifies which DOM properties a directives updates.\n   *\n   * ## Syntax\n   *\n   * ```\n   * @Directive({\n   *   selector: 'input',\n   *   hostProperties: {\n   *     'value': 'value'\n   *   }\n   * })\n   * class InputDirective {\n   *   value:string;\n   * }\n   *\n   * In this example every time the value property of the decorator changes, Angular will update the value property of\n   * the host element.\n   * ```\n   */\n  hostProperties:any; // String map\n\n  /**\n   * Specifies static attributes that should be propagated to a host element. Attributes specified in `hostAttributes`\n   * are propagated only if a given attribute is not present on a host element.\n   *\n   * ## Syntax\n   *\n   * ```\n   * @Directive({\n   *   selector: '[my-button]',\n   *   hostAttributes: {\n   *     'role': 'button'\n   *   }\n   * })\n   * class MyButton {\n   * }\n   *\n   * In this example using `my-button` directive (ex.: `<div my-button></div>`) on a host element (here: `<div>` )\n   * will ensure that this element will get the \"button\" role.\n   * ```\n   */\n  hostAttributes:any; // String map\n\n  /**\n   * Specifies which DOM methods a directive can invoke.\n   *\n   * ## Syntax\n   *\n   * ```\n   * @Directive({\n   *   selector: 'input',\n   *   hostActions: {\n   *     'emitFocus': 'focus()'\n   *   }\n   * })\n   * class InputDirective {\n   *   constructor() {\n   *     this.emitFocus = new EventEmitter();\n   *   }\n   *\n   *   focus() {\n   *     this.emitFocus.next();\n   *   }\n   * }\n   *\n   * In this example calling focus on InputDirective will result in calling focus on the DOM element.\n   * ```\n   */\n  hostActions:any; // String map\n\n  /**\n   * Specifies a set of lifecycle hostListeners in which the directive participates.\n   *\n   * See {@link onChange}, {@link onDestroy}, {@link onAllChangesDone} for details.\n   */\n  lifecycle:List; //List<LifecycleEvent>\n\n  /**\n   * If set to true the compiler does not compile the children of this directive.\n   */\n  //TODO(vsavkin): This would better fall under the Macro directive concept.\n  compileChildren: boolean;\n\n  @CONST()\n  constructor({\n      selector,\n      properties,\n      events,\n      hostListeners,\n      hostProperties,\n      hostAttributes,\n      hostActions,\n      lifecycle,\n      compileChildren = true,\n    }:{\n      selector:string,\n      properties:any,\n      events:List,\n      hostListeners: any,\n      hostProperties: any,\n      hostAttributes: any,\n      hostActions: any,\n      lifecycle:List,\n      compileChildren:boolean\n    }={})\n  {\n    super();\n    this.selector = selector;\n    this.properties = properties;\n    this.events = events;\n    this.hostListeners = hostListeners;\n    this.hostProperties = hostProperties;\n    this.hostAttributes = hostAttributes;\n    this.hostActions = hostActions;\n    this.lifecycle = lifecycle;\n    this.compileChildren = compileChildren;\n  }\n\n  /**\n   * Returns true if a directive participates in a given `LifecycleEvent`.\n   *\n   * See {@link onChange}, {@link onDestroy}, {@link onAllChangesDone} for details.\n   */\n  hasLifecycleHook(hook:string):boolean {\n    return isPresent(this.lifecycle) ? ListWrapper.contains(this.lifecycle, hook) : false;\n  }\n}\n\n/**\n * Declare reusable UI building blocks for an application.\n *\n * Each Angular component requires a single `@Component` and at least one `@View` annotation. The `@Component`\n * annotation specifies when a component is instantiated, and which properties and hostListeners it binds to.\n *\n * When a component is instantiated, Angular\n * - creates a shadow DOM for the component.\n * - loads the selected template into the shadow DOM.\n * - creates a child {@link Injector} which is configured with the `injectables` for the {@link Component}.\n *\n * All template expressions and statements are then evaluated against the component instance.\n *\n * For details on the `@View` annotation, see {@link View}.\n *\n * ## Example\n *\n * ```\n * @Component({\n *   selector: 'greet'\n * })\n * @View({\n *   template: 'Hello {{name}}!'\n * })\n * class Greet {\n *   name: string;\n *\n *   constructor() {\n *     this.name = 'World';\n *   }\n * }\n * ```\n *\n *\n * Dynamically loading a component at runtime:\n *\n * Regular Angular components are statically resolved. Dynamic components allows to resolve a component at runtime\n * instead by providing a placeholder into which a regular Angular component can be dynamically loaded. Once loaded,\n * the dynamically-loaded component becomes permanent and cannot be changed.\n * Dynamic components are declared just like components, but without a `@View` annotation.\n *\n *\n * ## Example\n *\n * Here we have `DynamicComp` which acts as the placeholder for `HelloCmp`. At runtime, the dynamic component\n * `DynamicComp` requests loading of the `HelloCmp` component.\n *\n * There is nothing special about `HelloCmp`, which is a regular Angular component. It can also be used in other static\n * locations.\n *\n * ```\n * @Component({\n *   selector: 'dynamic-comp'\n * })\n * class DynamicComp {\n *   helloCmp:HelloCmp;\n *   constructor(loader:DynamicComponentLoader, location:ElementRef) {\n *     loader.load(HelloCmp, location).then((helloCmp) => {\n *       this.helloCmp = helloCmp;\n *     });\n *   }\n * }\n *\n * @Component({\n *   selector: 'hello-cmp'\n * })\n * @View({\n *   template: \"{{greeting}}\"\n * })\n * class HelloCmp {\n *   greeting:string;\n *   constructor() {\n *     this.greeting = \"hello\";\n *   }\n * }\n * ```\n *\n *\n * @exportedAs angular2/annotations\n */\nexport class Component extends Directive {\n  /**\n   * Defines the used change detection strategy.\n   *\n   * When a component is instantiated, Angular creates a change detector, which is responsible for propagating\n   * the component's bindings.\n   *\n   * The `changeDetection` property defines, whether the change detection will be checked every time or only when the component\n   * tells it to do so.\n   */\n  changeDetection:string;\n\n  /**\n   * Defines the set of injectable objects that are visible to a Component and its children.\n   *\n   * The `injectables` defined in the Component annotation allow you to configure a set of bindings for the component's\n   * injector.\n   *\n   * When a component is instantiated, Angular creates a new child Injector, which is configured with the bindings in\n   * the Component `injectables` annotation. The injectable objects then become available for injection to the component\n   * itself and any of the directives in the component's template, i.e. they are not available to the directives which\n   * are children in the component's light DOM.\n   *\n   *\n   * The syntax for configuring the `injectables` injectable is identical to {@link Injector} injectable configuration.\n   * See {@link Injector} for additional detail.\n   *\n   *\n   * ## Simple Example\n   *\n   * Here is an example of a class that can be injected:\n   *\n   * ```\n   * class Greeter {\n   *    greet(name:string) {\n   *      return 'Hello ' + name + '!';\n   *    }\n   * }\n   *\n   * @Component({\n   *   selector: 'greet',\n   *   injectables: [\n   *     Greeter\n   *   ]\n   * })\n   * @View({\n   *   template: `{{greeter.greet('world')}}!`,\n   *   directives: Child\n   * })\n   * class HelloWorld {\n   *   greeter:Greeter;\n   *\n   *   constructor(greeter:Greeter) {\n   *     this.greeter = greeter;\n   *   }\n   * }\n   * ```\n   */\n  injectables:List;\n\n  // TODO(naomib): needs documentation\n  /**\n   * Dependency injection tokens that this component publishes _itself_ to its\n   * children in its view via the application injector.\n   *\n   * ## Examples\n   *\n   * Imagine you have parent component that implements the [RpcService]\n   * interface. It can pose as [RpcService] to its children. Child components\n   * do not need to know about this fact. They only need to declare their\n   * dependency on [RpcService] without knowing exactly how it is provided.\n   *\n   * ```\n   * @Component({\n   *   selector: 'parent',\n   *   publishAs: [RpcService]\n   * })\n   * @View({\n   *   template: '<child></child>',\n   *   directives: [Child]\n   * })\n   * class Parent implements RpcService {\n   * }\n   *\n   * @Component({\n   *   selector: 'child'\n   * })\n   * class Child {\n   *   // Just asks for RpcService; doesn't know that it's Parent.\n   *   constructor(RpcService rpc);\n   * }\n   * ```\n   */\n  publishAs:List;\n\n  @CONST()\n  constructor({\n      selector,\n      properties,\n      events,\n      hostListeners,\n      hostProperties,\n      hostAttributes,\n      hostActions,\n      injectables,\n      lifecycle,\n      changeDetection = DEFAULT,\n      compileChildren = true,\n      publishAs\n    }:{\n      selector:string,\n      properties:Object,\n      events:List,\n      hostListeners:any,\n      hostProperties:any,\n      hostAttributes:any,\n      hostActions:any,\n      injectables:List,\n      lifecycle:List,\n      changeDetection:string,\n      compileChildren:boolean,\n      publishAs:List\n    }={})\n  {\n    super({\n      selector: selector,\n      properties: properties,\n      events: events,\n      hostListeners: hostListeners,\n      hostProperties: hostProperties,\n      hostAttributes: hostAttributes,\n      hostActions: hostActions,\n      lifecycle: lifecycle,\n      compileChildren: compileChildren\n    });\n\n    this.changeDetection = changeDetection;\n    this.injectables = injectables;\n    this.publishAs = publishAs;\n  }\n}\n\n\n//TODO(misko): turn into LifecycleEvent class once we switch to TypeScript;\n\n/**\n * Notify a directive whenever a {@link View} that contains it is destroyed.\n *\n * ## Example\n *\n * ```\n * @Directive({\n *   ...,\n *   lifecycle: [onDestroy]\n * })\n * class ClassSet {\n *   onDestroy() {\n *     // invoked to notify directive of the containing view destruction.\n *   }\n * }\n * ```\n * @exportedAs angular2/annotations\n */\nexport const onDestroy = \"onDestroy\";\n\n\n/**\n * Notify a directive when any of its bindings have changed.\n *\n * This method is called right after the directive's bindings have been checked,\n * and before any of its children's bindings have been checked.\n *\n * It is invoked only if at least one of the directive's bindings has changed.\n *\n * ## Example:\n *\n * ```\n * @Directive({\n *   selector: '[class-set]',\n *   properties: {\n *     'propA': 'propA'\n *     'propB': 'propB'\n *   },\n *   lifecycle: [onChange]\n * })\n * class ClassSet {\n *   propA;\n *   propB;\n *   onChange(changes:{[idx: string, PropertyUpdate]}) {\n *     // This will get called after any of the properties have been updated.\n *     if (changes['propA']) {\n *       // if propA was updated\n *     }\n *     if (changes['propA']) {\n *       // if propB was updated\n *     }\n *   }\n * }\n *  ```\n * @exportedAs angular2/annotations\n */\nexport const onChange = \"onChange\";\n\n/**\n * Notify a directive when the bindings of all its children have been changed.\n *\n * ## Example:\n *\n * ```\n * @Directive({\n *   selector: '[class-set]',\n *   lifecycle: [onAllChangesDone]\n * })\n * class ClassSet {\n *\n *   onAllChangesDone() {\n *   }\n *\n * }\n *  ```\n * @exportedAs angular2/annotations\n */\nexport const onAllChangesDone = \"onAllChangesDone\";\n"]}